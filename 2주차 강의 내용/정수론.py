'''
실수연산은 최대한 피하는 방향 (오차가 발생하는 경우 발생)
0.1 + 0.2 == 0.3  false 나옴  -> x10을 해줘서 정수로 풀자





정수론

1. 소수 판정
2. 약수 구하기(약수의 개수가 짝수)
3. 소인수 분해

4. 유클리드 호제법 (GCD, LCM)
5. 에라토스테네스의 체

6.1부터 n까지 x의 배수의 개수 => n//x
7.n!에 곱해진 소수 x의 개수
'''

# 숫자 한줄에 하나 출력
import math
x = 13247

while x > 0:
    print(x % 10)
    x //= 10


n = int(input())

ans = n - 1
for i in range(1, int(math.sqrt(n)) + 1):
    if n % i == 0:
        x = i
        y = n // i

        area = abs(x - y)
        ans = min(ans, area)
        #ans = min(ans, abs(i - n // i))

print(ans)


'''


직사각형 넓이 => n으로 주어진다.
이 직사각형의 가로 길이와 세로 길이는 모두 정수.
가로 세로 길이의 차이가 가장 작은 경우 그 차이?

20

1   2   4   5   10  20


n제한 10^12


n => 소수? 합성수?

n의 약수를 모두 구해서 카운팅했을 때 2개인지 확인?




n == 1인 상황에서 소수로 판정.

cnt = 0
for i in range(2, sqrt(n) + 1):
    if n % i == 0:
        cnt += 1

if n != 1 and cnt == 0:
    print('소수')



약수
for i in range(1, sqrt(n) + 1):
    if n % i == 0:
        print(i)
        
        if i != n // i:
            print(n // i)


12
1   12
2   6
3   4

36

1   36
2   18
3   12
4   9
6


1   2   3
12  6   4


12의 약수
1 2 3 4 6 12

1   12
2   6
3   4
루트n 루트n => n


2~n-1

루트n 이하
루트n 이상






24

2   2   2   3

소인수 분해
for i in range(2, sqrt(n) + 1):
    while n % i == 0:
        print(i)
        n //= i

if n != 1:
    print(n)
    
    
    
    

n = a * b * c * d * e * f

1. n의 모든 소인수를 곱하면 n
2. 루트n보다 큰 수 둘은 곱하면 n보다 크다.
=> n의 소인수에는 루트n보다 큰게 없거나 하나 존재한다.


1) 모든 소인수가 루트n 이하인 경우
2) 제일 큰 소인수 하나만 루트n보다 큰 경우




gcd(a, b) == gcd(a - b, b)





def get_gcd(a, b):
    while a % b != 0:
        a, b = b, a % b
    
    return b



a = 2^5 * 3^3 * 7^1
b = 2^3 * 3^5 * 7^0

gcd = 2^3 * 3^3 * 7^0
lcm = 2^5 * 3^5 * 7^1
a * b // gcd => lcm



1~30 각 수가 소수인지 아닌지

x   2   3   x   5   x   7   x   x   x
11  x   13  x   x   x   17  x   19  x
x   x   23  x   x   x   x   x   29  x


7의 배수 => 14 21 28 35 42 49 56...
7 * 7



1. 1을 제외하고 모두 소수라고 가정.
2. 2부터 아래 과정을 반복.
2-1) 이 수가 소수라면 배수를 제거.
2-2) 이 수가 소수가 아니라면 스킵.


is_prime = [True for i in range(n + 1)]

is_prime[1] = False
for i in range(2, n + 1):
    if not is_prime[i]:
        continue
    
    for j in range(i * i, n + 1, i):
        is_prime[j] = False



1부터 20까지 6의 배수? => 3개
1부터 23까지 6의 배수? => 3개
1부터 24까지 6의 배수? => 4개

1부터 n까지 x의 배수? => n // x개



정수론

(조심할점 언급)
1. 소수 판정 => 2부터 루트n까지 약수가 하나도 없으면 자동으로 루트n부터 n - 1까지도 약수가 없다. 쌍이 없으니까. 주의할점 : 1은 소수가 아니다.
2. 약수 구하기 => 원리는 소수 판정과 동일. 주의할점 : 완전제곱수의 경우 마지막 쌍이 두번 나오니 하나만 나오도록 처리. +) 약수의 개수가 홀수 == 완전 제곱수 
3. 소인수 분해 => 루트n보다 큰 소인수는 많아야 한개. 2~루트n까지의 소인수를 모두 구한 뒤 남은게 있다면 그게 마지막 소인수. 조심할점 : 하나 남은거 처리 해줘야 한다.

4. 유클리드 호제법 (GCD, LCM) => gcd는 함수. lcm(a, b) == a * b // gcd(a, b)
5. 에라토스테네스의 체 => 1~n 소수 판정 O(nlogn) => 응용 버전으로 각 수의 가장 작은 소인수를 구하는 체 등이 가능.

6. 1부터 n까지 x의 배수의 개수 => n // x
7. n!에 곱해진 소수 x의 개수 => 숙제 풀이(다음주)







'''
